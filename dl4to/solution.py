# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/solution/1_solution.ipynb (unless otherwise specified).

__all__ = ['Solution']

# Internal Cell
import numpy as np

# Internal Cell
def add_corners(solution):
    solution._θ[:,0,0,0] = 1.
    solution._θ[:,0,0,-1] = 1.
    solution._θ[:,0,-1,0] = 1.
    solution._θ[:,-1,0,0] = 1.
    solution._θ[:,-1,-1,-1] = 1.
    solution._θ[:,-1,-1,0] = 1.
    solution._θ[:,0,-1,-1] = 1.
    solution._θ[:,-1,0,-1] = 1.
    solution._θ[:,0,0,2] = 1.
    solution._θ[:,0,2,0] = 1.
    solution._θ[:,2,0,0] = 1.
    solution._θ[:,2,2,2] = 1.
    solution._θ[:,2,2,0] = 1.
    solution._θ[:,0,2,2] = 1.
    solution._θ[:,2,0,2] = 1.
    return solution

# Internal Cell
class PlottingForSolution:
    @staticmethod
    def __call__(
        solution,
        binary=False,
        solve_pde=True,
        normalize_σ_vm=True,
        threshold=0.,
        display=True,
        file_path=None,
        camera_position=(0,.1,.12),
        show_design_space=False,
        use_pyvista=False,
        window_size=(800,800),
        smooth_iters=0,
        show_colorbar=True,
        show_axislabels=False,
        show_ticklabels=False,
        export_png=False,
    ):

        file_path_ = file_path
        if use_pyvista and smooth_iters > 0:
            solution = add_corners(solution)
        θ = solution.get_θ(binary=binary).cpu().detach().numpy()
        if use_pyvista:
            plotting_kwargs = {'problem': solution.problem,
                               'display': display,
                               'camera_position': camera_position,
                               'show_design_space': show_design_space,
                               'window_size': window_size,
                               'smooth_iters': smooth_iters}
        else:
            plotting_kwargs = {'problem': solution.problem,
                               'display': display,
                               'camera_position': camera_position,
                               'show_design_space': show_design_space,
                               'show_colorbar': show_colorbar,
                               'show_axislabels': show_axislabels,
                               'show_ticklabels':show_ticklabels,
                               'export_png':export_png}

        plotting_data_dict ={
            'data': [None],
            'title': ['Density distribution θ', 'Normed displacements |u|'],
            'file_path_suffix': ['density',
                                 'displacement',
                                 'stress']
        }

        if solve_pde and (solution.pde_solver == None):
            print("Cannot plot PDE solution because no PDE solver is attached to solution.problem.")
            solve_pde = False

        if solve_pde:
            u, σ, σ_vm = solution.solve_pde(p=1., binary=binary)
            u_norm = np.linalg.norm(u.cpu().detach().numpy(), axis=0)
            plotting_data_dict['data'].append(u_norm)
            σ_vm_ = σ_vm.cpu().detach().numpy()
            if normalize_σ_vm:
                plotting_data_dict['data'].append(σ_vm_ / solution.problem.σ_ys)
                plotting_data_dict['title'].append('Normalized von Mises stresses σ_vm/σ_ys')
            else:
                plotting_data_dict['data'].append(σ_vm_)
                plotting_data_dict['title'].append('Von Mises stresses σ_vm')


        for i in range(len(plotting_data_dict['data'])):
            if use_pyvista:
                pyvista_plot_scalar_field(
                    scalar_field=θ,
                    data=plotting_data_dict['data'][i],
                    threshold=threshold,
                    title=plotting_data_dict['title'][i],
                    **plotting_kwargs
                )
            else:
                if file_path != None:
                    file_path_ = f"{file_path}_{plotting_data_dict['file_path_suffix'][i]}"
                plot_scalar_field(
                    scalar_field=θ,
                    data=plotting_data_dict['data'][i],
                    threshold=threshold,
                    title=plotting_data_dict['title'][i],
                    file_path=file_path_,
                    **plotting_kwargs
                )

# Internal Cell
import copy
import torch
import numpy as np
from typing import Union

from .solution import PlottingForSolution

# Cell
class Solution:
    """
    A class that defines solution objects.
    """
    def __init__(self,
                 problem:"dl4to.problem.Problem", # The problem to which this is a solution.
                 θ:torch.Tensor, # The tensor that defines a density distribution that solves the TO problem.
                 name:str=None, # The name of the solution.
                 enforce_θ_on_Ω_design:bool=True # Whether the density distribution should be modified such that it fulfills the density restrictions imposed by the problem object.
                ):
        self.enforce_θ_on_Ω_design = enforce_θ_on_Ω_design
        self.name = name
        self._problem = problem
        self.θ = θ
        self._check_θ_shape_and_range()

    def plot(self, **kwargs):
        print("WARNING: Plotting is removed from library")

    @property
    def θ(self):
        return self._θ


    @θ.setter
    def θ(self, θ_new):
        self._θ = θ_new
        if self.enforce_θ_on_Ω_design:
            Ω_design = self.problem.Ω_design.to(θ_new.device)
            self._θ = torch.where(Ω_design == -1., self.θ, Ω_design.type(self.θ.dtype))
        self.u = None
        self.u_binary = None


    @property
    def pde_solver(self):
        return self.problem.pde_solver


    @pde_solver.setter
    def pde_solver(self, new_pde_solver):
        self.problem._pde_solver = new_pde_solver
        self.u = None
        self.u_binary = None


    @property
    def dtype(self):
        return self.θ.dtype


    @dtype.setter
    def dtype(self, dtype):
        self.problem.dtype = dtype
        self.θ = self.θ.type(dtype)


    @property
    def problem(self):
        return self._problem


    @property
    def shape(self):
        return self.problem.shape


    @property
    def device(self):
        return self.θ.device


    @device.setter
    def device(self, device):
        self.θ = self.θ.to(device)
        if self.u is not None:
            self.u = self.u.to(device)
        if self.u_binary is not None:
            self.u_binary = self.u_binary.to(device)


    def to(self, device):
        """
        Moves the solution object to `device`.
        """
        self.device = device
        return self


    def get_θ(self,
              binary:bool=False # Whether the density should be binarized, i.e., thresholded at 0.5
             ):
        """
        Returns the density distribution `θ` from the solution object. Note that you can also obtain that density via `Solution.θ`, however this function has the option to return
        a binarized version of it.
        """
        if binary:
            θ_round = torch.zeros_like(self.θ)
            θ_round[self.θ > .5] = 1.
            return θ_round
        return self.θ


    def clone(self):
        """
        Returns a deepcopy of the Solution object.
        """
        return Solution(problem=self.problem,
                        θ=self.θ.clone(),
                        name=self.name,
                        enforce_θ_on_Ω_design=self.enforce_θ_on_Ω_design)


    def detach(self):
        """
        Returns a clone of the solution object that has a density θ which is detached from its computational graph.
        """
        detached_solution = self.clone()
        detached_solution._θ = self._θ.detach()
        return detached_solution


    def detach_(self):
        """
        Detaches θ from its computational graph. This is an in-place version of the `detach()` method.
        """
        self._θ.detach_()


    def solve_pde(self,
                  p:float=1., # Denotes the SIMP exponent and should usually be left at its default value of 1.
                  binary:bool=False # Whether the density should be binarized before solving the PDE.
                 ):
        """
        Solves the PDE of linear elasticity for the current solution. Returns the displacement tensor, stress tensor and the von Mises stress tensor.
        """
        if self.pde_solver is None:
            raise AttributeError("solution.problem has no PDE solver attached to it.")
        u, σ, σ_vm = self.pde_solver(self, p=p, binary=binary)
        u = u.to(self.θ.device)
        σ = σ.to(self.θ.device)
        σ_vm = σ_vm.to(self.θ.device)
        return u, σ, σ_vm


    def _check_θ_shape_and_range(self, θ=None):
        if θ is None:
            θ = self.θ

        if θ is None:
            return

        if not isinstance(θ, torch.Tensor):
            raise TypeError("θ must be None or a torch.Tensor")

        if len(θ.shape) != 4 or θ.shape[0] != 1:
            print(θ.shape)
            raise ValueError("θ tensor is not of the right shape.")

        if torch.any(θ < 0) or torch.any(1 < θ):
            raise ValueError("θ tensor contrains values outside the interval [0, 1].")

        if "Problem" not in str(self.problem):
            raise TypeError("problem must be an Problem")

        if θ is not None:
            if not np.all(θ.shape[1:] == self.shape):
                raise ValueError("θ does not fit to the associated Problem.")


    def eval(self,
             criterion:"dl4to.criteria.Criterion" # The criterion for which the solution should be evaluated.
            ):
        """
        Evaluate the solution object with `criterion`. Only works for unsupervised criteria. Returns a `torch.Tensor`.
        """
        assert ~criterion.supervised, print("`solution.eval()` only works for unsupervised criteria.")
        return criterion([self])


    def __rmul__(self,
                 λ:float # The multiplier for the density.
                ):
        """
        Multiplication of a solution with a scalar returns a clone of the solution that has the original density distribution that is rescaled with `λ`. Returns a new `solution` object.
        """
        solution = self.clone()
        solution.θ = λ * self.θ
        return solution


    def __mul__(self,
                λ:float # The multiplier for the density.
               ):
        """
        Multiplication of a solution with a scalar returns a clone of the solution that has the original density distribution that is rescaled with `λ`. Returns a new `solution` object.
        """
        return self.__rmul__(λ)