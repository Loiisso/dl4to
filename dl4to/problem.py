# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/problem/2_problem.ipynb (unless otherwise specified).

__all__ = ['Problem']

# Internal Cell
from .plotting import plot_scalar_field, pyvista_plot_scalar_field, plot_vector_field

# Internal Cell
class PlottingForProblem:
    @staticmethod
    def __call__(
        problem,
        display=True,
        file_path=None,
        camera_position=(0,.1,.12),
        use_pyvista=False,
        window_size=(800,800),
        smooth_iters=0,
        show_colorbar=True,
        show_axislabels=False,
        show_ticklabels=False,
        export_png=False,
    ):
        file_path_ = file_path

        if use_pyvista:
            pyvista_plotting_kwargs = {'problem': problem,
                               'display': display,
                               'camera_position': camera_position,
                               'window_size': window_size,
                               'smooth_iters': smooth_iters}

        plotting_kwargs = {'problem': problem,
                           'display': display,
                           'camera_position': camera_position,
                           'show_colorbar': show_colorbar,
                           'show_axislabels': show_axislabels,
                           'show_ticklabels':show_ticklabels,
                           'export_png':export_png}

        scalar_field_plotting_dict ={
            'scalar_field': [problem.Ω_dirichlet.sum(dim=0).cpu().detach().numpy(),
                             (problem.Ω_design.squeeze() != 0).cpu().detach().numpy(),
                             (problem.F.norm(dim=0) != 0).cpu().detach().numpy()],
            'data': [problem.Ω_dirichlet.sum(dim=0).cpu().detach().numpy(),
                     problem.Ω_design.squeeze().cpu().detach().numpy(),
                     (problem.F.norm(dim=0) != 0).cpu().detach().numpy()],
            'title': ['Locations of homogeneous Dirichlet boundary conditions',
                      'Design space information',
                      'Force locations'],
            'file_path_suffix': ['dirichlet',
                                 'design_space',
                                 'force_locations']
        }


        for i in range(3):
            if use_pyvista:
                pyvista_plot_scalar_field(
                    scalar_field=scalar_field_plotting_dict['scalar_field'][i],
                    data=scalar_field_plotting_dict['data'][i],
                    threshold=0.,
                    title=scalar_field_plotting_dict['title'][i],
                    **pyvista_plotting_kwargs
                )
            else:
                if file_path != None:
                    file_path_ = f"{file_path}_{scalar_field_plotting_dict['file_path_suffix'][i]}"
                plot_scalar_field(
                    scalar_field=scalar_field_plotting_dict['scalar_field'][i],
                    data=scalar_field_plotting_dict['data'][i],
                    threshold=0.,
                    title=scalar_field_plotting_dict['title'][i],
                    file_path=file_path_,
                    **plotting_kwargs
                )

        if file_path != None:
            file_path_ = f"{file_path}_force_directions"

        plot_vector_field(
            vector_field=problem.F,
            title="Force directions",
            file_path=file_path_,
            **plotting_kwargs
        )

# Internal Cell
import torch
import numpy as np

# Internal Cell
class InputCheckerForProblem:
    @staticmethod
    def check_init(problem):
        InputCheckerForProblem._check_all_non_tensor_constructur_arguments(problem)
        InputCheckerForProblem._check_all_tensor_constructur_arguments(problem)
        InputCheckerForProblem._ckeck_consistency_of_design_space_data(problem)


    @staticmethod
    def _check_all_non_tensor_constructur_arguments(problem):
        if not isinstance(problem._name, str):
            if problem._name is not None:
                raise TypeError("name must be given as a String.")

        if type(problem._h) != torch.Tensor or len(problem._h) != 3:
            raise ValueError("h must be a 1d-array of length 3.")

        if torch.any(problem._h <= 0.):
            raise ValueError("The values in h must be larger than 0.")

        if not np.isscalar(problem._E):
            raise ValueError("E must be scalar.")

        if not np.isscalar(problem._ν):
            raise ValueError("ν must be scalar.")


    @staticmethod
    def _check_all_tensor_constructur_arguments(problem):
        if len(problem.Ω_dirichlet.shape) != 4 or problem.Ω_dirichlet.shape[0] != 3:
            raise ValueError("Ω_dirichlet tensor is not of the right shape.")

        if len(problem.Ω_design.shape) != 4 or problem.Ω_design.shape[0] != 1:
            raise ValueError("Ω_design tensor is not of the right shape.")

        if len(problem.F.shape) != 4 or problem.F.shape[0] != 3:
            raise ValueError("F tensor is not of the right shape.")

        if not (problem.Ω_dirichlet.shape[-3:] == problem.Ω_design.shape[-3:] == problem.F.shape[-3:]):
            raise ValueError("shapes of shapepaces are inconsistent.")


    @staticmethod
    def _ckeck_consistency_of_design_space_data(problem):
        if not torch.all((problem.Ω_design == -1) + (problem.Ω_design == 0) + (problem.Ω_design == 1)):
            raise ValueError("Design-Space tensor cannot have values other than -1, 0, 1")

        if not torch.all((problem.Ω_dirichlet == 0) + (problem.Ω_dirichlet == 1)):
            raise ValueError("Tensor of Dirichlet BC locations cannot have values other than 0 and 1")

# Internal Cell
import copy
import torch
import numpy as np
from typing import Union

from .problem import PlottingForProblem, InputCheckerForProblem
from .topo_solvers import TrivialSolver

# Cell
class Problem:
    """
    A class containing all parameters for defining a topology optimization problem.
    """
    def __init__(
        self,
        E:float, # The Young's modulus of the material. Given in Pa.
        ν:float, # The Poisson's ratio of the material. Dimensionless.
        σ_ys:float, #The yield stress σ_ys denotes the critical von Mises stress at which the material starts yielding. Given in Pa.
        h:Union[float,list], # The length of the edges of the cuboid voxels. Equal to the discretisation step size in each coordinate direction.
        Ω_dirichlet:torch.Tensor, #A tensor denoting the presence of homogeneous Dirichlet boundary conditions in each voxel in each coordinate direction.
        Ω_design:torch.Tensor, # A tensor denoting the kind of design space assigned to each voxel. Values of "0" and "1" indicate a material density fixed at 0 or 1, respectively. "-1" indicates the absence of constraints, i.e., the voxel density can be freely optimized.
        F:torch.Tensor, # A tensor denoting the forces applied to each voxel in each coordinate direction. Given in N/m^3.
        pde_solver:"dl4to.pde.PDESolver"=None, # A dl4to PDE Solver object that is attached to this problem.
        name:str=None, # The name of the problem
        device:str='cpu', # The device that this problem is to be stored on. Possible options are "cpu" and "cuda".
        dtype:torch.dtype=torch.float32, # The datatype of the problem.
        restrict_density_for_voxels_with_applied_forces:bool=True # Determines whether Ω_design should be set to "1" for voxels that have forces applied to them. Should be turned of in case of volumetric forces like gravity that are applied to all voxels.
    ):
        self._dtype = dtype
        self._device = device
        self._E, self._ν, self._σ_ys = E, ν, σ_ys
        if type(h) == list or type(h) == np.ndarray:
            h = torch.tensor(h)
        if type(h) == int or type(h) == float:
            h = torch.tensor([h,h,h])
        self._h = h
        self._Ω_dirichlet = Ω_dirichlet.type(torch.bool).to(device)
        self._Ω_design = Ω_design.type(dtype).to(device)
        self._F = F.type(dtype).to(device)
        self._shape = self.Ω_design.shape[-3:]
        self._size = (torch.tensor(self.shape) * self.h).tolist()
        if restrict_density_for_voxels_with_applied_forces:
            F_mask = (self.F != 0).sum(dim=0, keepdim=True).bool()
            self._Ω_design[F_mask] = 1.
        self._name = name
        self.trivial_solution = TrivialSolver()(self)
        self.pde_solver = pde_solver
        InputCheckerForProblem.check_init(problem=self)


    @property
    def pde_solver(self):
        return self._pde_solver


    @pde_solver.setter
    def pde_solver(self, pde_solver):
        if pde_solver is None:
            self._pde_solver = pde_solver
        else:
            self._pde_solver = pde_solver.clone()
            if self._pde_solver.assemble_tensors_when_passed_to_problem:
                self._pde_solver.assemble_tensors(self)
            self.trivial_solution.u = None
            self.trivial_solution.u_binary = None


    @property
    def name(self):
        return self._name


    @property
    def dtype(self):
        return self._dtype


    @dtype.setter
    def dtype(self, dtype):
        self._dtype = dtype
        self._Ω_design = self._Ω_design.type(dtype)
        self._F = self._F.type(dtype)
        if self.pde_solver is not None:
            self.pde_solver.dtype = dtype


    @property
    def h(self):
        return self._h


    @property
    def E(self):
        return self._E


    @property
    def ν(self):
        return self._ν


    @property
    def σ_ys(self):
        return self._σ_ys


    @property
    def Ω_dirichlet(self):
        return self._Ω_dirichlet


    @property
    def Ω_design(self):
        return self._Ω_design


    @property
    def F(self):
        return self._F


    @property
    def shape(self):
        return self._shape


    @property
    def size(self):
        return self._size


    @property
    def device(self):
        return self._device


    @device.setter
    def device(self, device):
        self._Ω_dirichlet = self._Ω_dirichlet.to(device)
        self._Ω_design = self._Ω_design.to(device)
        self._F = self._F.to(device)
        self._device = device
        if self.pde_solver is not None:
            self.pde_solver.device = device


    def clone(self):
        """
        Returns a deepcopy of the Problem object.
        """
        return copy.deepcopy(self)
